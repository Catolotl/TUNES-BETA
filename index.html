<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tunes — YouTube + iTunes + Lyrics (Updated)</title>
  <style>
    :root{
      --bg: linear-gradient(180deg,#001414,#000);
      --surface:#232323; --card:#181818; --hover:#282828;
      --text:#fff; --muted:#b3b3b3; --accent:#32CD32; --border:#000;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text);height:100vh;display:flex;overflow:hidden}
    header{position:fixed;top:0;left:0;right:0;height:72px;padding:8px 18px;display:flex;align-items:center;gap:12px;z-index:40;background:transparent;border-bottom:5px solid var(--border)}
    header h2{margin:0;font-size:1.2rem;font-weight:700;background:linear-gradient(90deg,#fff,#ccc);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .header-left{display:flex;align-items:center;gap:12px}
    .nav-item{padding:8px 12px;border-radius:16px;background:rgba(255,255,255,0.04);cursor:pointer}
    .nav-item.active{background:rgba(255,255,255,0.08)}
    #header-search{flex:1;max-width:720px;padding:12px 14px;border-radius:14px;border:none;background:var(--card);color:var(--text);font-size:0.95rem}
    #profile-btn{width:36px;height:36px;border-radius:50%;background:#333;display:flex;align-items:center;justify-content:center;cursor:pointer}
    #main-wrapper{display:flex;flex:1;margin-top:72px;width:100%}
    #sidebar{width:320px;background:var(--surface);padding:18px;border-right:5px solid var(--border);overflow:auto}
    #content{flex:1;padding:20px 28px;overflow:auto}
    .muted{color:var(--muted)}
    /* Home layout */
    #home-page .greeting{font-size:1.6rem;margin-bottom:18px;font-weight:700}
    .recent-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-bottom:20px}
    .recent-item{display:flex;align-items:center;gap:12px;background:var(--card);padding:10px;border-radius:10px;cursor:pointer}
    .recent-item img{width:84px;height:56px;object-fit:cover;border-radius:6px;flex-shrink:0}
    .recent-meta{display:flex;flex-direction:column}
    .recent-title{font-weight:700}
    .section{margin-bottom:20px}
    .section h3{margin:0 0 10px 0}
    .stacked {display:flex;flex-direction:column;gap:10px}
    /* Results */
    .results{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
    .song-card{display:flex;gap:12px;align-items:center;padding:10px;border-radius:10px;background:var(--card)}
    .song-art{width:88px;height:88px;border-radius:8px;object-fit:cover;flex-shrink:0}
    .song-info{display:flex;flex-direction:column}
    .song-title{font-weight:700}
    .song-artist{color:var(--muted);font-size:0.9rem}
    .video-results{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
    .video-card{background:var(--card);padding:10px;border-radius:10px}
    /* Player */
    #player-area{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.4);margin-top:18px}
    #video-player{width:100%;height:360px;border-radius:8px;border:none;background:#000}
    .controls{display:flex;align-items:center;gap:8px;margin-top:10px}
    .small{font-size:0.85rem;color:var(--muted)}
    /* Sidebar playlists */
    .playlist-item{padding:8px;border-radius:8px;display:flex;align-items:center;gap:8px;cursor:pointer}
    .playlist-cover{width:44px;height:44px;border-radius:6px;object-fit:cover}
    /* Migration modal / log */
    #migration-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:80}
    #migration-box{width:92%;max-width:920px;background:var(--card);padding:16px;border-radius:12px;border:1px solid var(--border);max-height:80vh;overflow:auto}
    .mapping-row{display:flex;gap:10px;align-items:flex-start;padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)}
    .mapping-original{flex:1}
    .mapping-match{flex:1}
    .mapping-actions{display:flex;gap:8px;align-items:center}
    @media (max-width:1000px){
      .recent-grid{grid-template-columns:repeat(2,1fr)}
      #sidebar{display:none}
      #video-player{height:220px}
      #header-search{max-width:400px}
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <h2>Tunes</h2>
      <div id="home-nav" class="nav-item active">Home</div>
      <div id="search-nav" class="nav-item">Search</div>
      <div id="video-nav" class="nav-item">Music Videos</div>
    </div>

    <input id="header-search" placeholder="What do you want to play?" aria-label="Search" />

    <div style="display:flex;gap:8px;align-items:center">
      <div id="migration-open" class="nav-item">Migration Log</div>
      <div id="profile-btn">?</div>
    </div>
  </header>

  <div id="main-wrapper">
    <aside id="sidebar">
      <div style="font-weight:700;margin-bottom:10px">Your Library</div>
      <div style="margin-bottom:8px;color:var(--muted)">Playlists</div>
      <div id="playlists-list" style="display:flex;flex-direction:column;gap:8px;margin-bottom:14px"></div>
      <button id="create-playlist-btn" style="width:100%;margin-bottom:14px">Create Playlist</button>

      <div style="font-weight:700;margin-top:6px;margin-bottom:8px">Quick</div>
      <div class="playlist-item" id="sidebar-recent">
        <img class="playlist-cover" src="https://via.placeholder.com/44" alt="recent">
        <div style="flex:1">Recently Played</div>
      </div>
      <div class="playlist-item" id="sidebar-auto-top">
        <img class="playlist-cover" src="https://via.placeholder.com/44" alt="auto">
        <div style="flex:1">Auto — Top Recently</div>
      </div>
    </aside>

    <main id="content">
      <!-- Home page -->
      <div id="home-page">
        <div class="greeting" id="greeting">Good day, User</div>

        <div class="section">
          <h3>Recently Played</h3>
          <div class="recent-grid" id="recently-played"></div>
        </div>

        <div class="section">
          <h3>Made Playlists</h3>
          <div class="stacked" id="made-playlists"></div>
        </div>

        <div class="section">
          <h3>Auto-made Playlists</h3>
          <div class="stacked" id="auto-playlists"></div>
        </div>
      </div>

      <!-- Search page -->
      <div id="search-page" style="display:none">
        <div style="margin-bottom:12px;color:var(--muted)">Results for: <span id="search-query" style="font-weight:700"></span></div>
        <div id="search-results" class="results"></div>
      </div>

      <!-- Videos page -->
      <div id="video-page" style="display:none">
        <div style="margin-bottom:12px;color:var(--muted)">Video search results (shows video thumbnails)</div>
        <div id="video-results" class="video-results"></div>
      </div>

      <!-- Player -->
      <div id="player-area" style="display:none">
        <div id="video-player-wrapper">
          <iframe id="video-player" src="" allow="autoplay; encrypted-media" allowfullscreen></iframe>
        </div>

        <div class="controls">
          <button id="play-btn">Play</button>
          <button id="pause-btn">Pause</button>
          <button id="stop-btn">Stop</button>
          <div id="time-label" class="small">00:00 / 00:00</div>
          <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <button id="lyrics-btn">Lyrics</button>
            <button id="apply-art-btn">Apply iTunes Artwork</button>
            <button id="close-player-btn">Close</button>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
          <img id="now-cover" src="https://via.placeholder.com/88" class="song-art" alt="cover">
          <div>
            <div id="now-title" style="font-weight:700">—</div>
            <div id="now-artist" class="muted">—</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <div id="lyrics-box" style="display:none;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;max-height:240px;overflow:auto"></div>
        </div>
      </div>
    </main>
  </div>

  <!-- Migration modal / log -->
  <div id="migration-modal" role="dialog" aria-modal="true">
    <div id="migration-box">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <h3 style="margin:0">Migration Log</h3>
        <div><button id="close-migration">Close</button></div>
      </div>

      <div id="migration-list" style="display:flex;flex-direction:column;gap:8px"></div>

      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="accept-all-migration">Accept All</button>
        <button id="retry-migration">Retry Failed</button>
      </div>
    </div>
  </div>

  <script>
    // ========== CONFIG ==========
    const YOUTUBE_API_KEY = 'AIzaSyDNd7dwB1rZEpJzpyRrVZQwSKHvnt3Q7vQ';

    // ========== STATE ==========
    let userName = localStorage.getItem('userName') || 'User';
    let playlists = JSON.parse(localStorage.getItem('miniPlaylists') || '{}'); // user-made
    let recentlyPlayed = JSON.parse(localStorage.getItem('recentlyPlayed') || '[]');
    let migrationLog = JSON.parse(localStorage.getItem('migrationLog') || '[]'); // {original:{...}, match:{...}, status:'pending'|'accepted'|'failed'}
    let player = null;
    let currentVideo = null; // { videoId, title, channel, thumbnail, duration, artwork }
    let activeTab = 'home'; // 'home'|'search'|'video'
    let lastSearchQuery = '';

    // ========== DOM ==========
    const headerSearch = document.getElementById('header-search');
    const homeNav = document.getElementById('home-nav');
    const searchNav = document.getElementById('search-nav');
    const videoNav = document.getElementById('video-nav');
    const migrationOpen = document.getElementById('migration-open');
    const migrationModal = document.getElementById('migration-modal');
    const migrationList = document.getElementById('migration-list');
    const closeMigration = document.getElementById('close-migration');
    const acceptAllBtn = document.getElementById('accept-all-migration');
    const retryMigrationBtn = document.getElementById('retry-migration');

    const homePage = document.getElementById('home-page');
    const searchPage = document.getElementById('search-page');
    const videoPage = document.getElementById('video-page');

    const recentGrid = document.getElementById('recently-played');
    const madePlaylistsDiv = document.getElementById('made-playlists');
    const autoPlaylistsDiv = document.getElementById('auto-playlists');
    const searchResultsDiv = document.getElementById('search-results');
    const videoResultsDiv = document.getElementById('video-results');
    const searchQueryLabel = document.getElementById('search-query');

    const playlistsList = document.getElementById('playlists-list');
    const createPlaylistBtn = document.getElementById('create-playlist-btn');
    const sidebarRecent = document.getElementById('sidebar-recent');
    const sidebarAutoTop = document.getElementById('sidebar-auto-top');

    // Player UI
    const playerArea = document.getElementById('player-area');
    const iframeEl = document.getElementById('video-player');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const stopBtn = document.getElementById('stop-btn');
    const timeLabel = document.getElementById('time-label');
    const lyricsBtn = document.getElementById('lyrics-btn');
    const applyArtBtn = document.getElementById('apply-art-btn');
    const closePlayerBtn = document.getElementById('close-player-btn');
    const nowCover = document.getElementById('now-cover');
    const nowTitle = document.getElementById('now-title');
    const nowArtist = document.getElementById('now-artist');
    const lyricsBox = document.getElementById('lyrics-box');

    // ========== UTILITIES ==========
    function setActiveTab(tab) {
      activeTab = tab;
      homeNav.classList.toggle('active', tab === 'home');
      searchNav.classList.toggle('active', tab === 'search');
      videoNav.classList.toggle('active', tab === 'video');
      homePage.style.display = tab === 'home' ? 'block' : 'none';
      searchPage.style.display = tab === 'search' ? 'block' : 'none';
      videoPage.style.display = tab === 'video' ? 'block' : 'none';

      // When not on video tab, hide iframe visually (we still use it for playback)
      iframeEl.style.display = tab === 'video' ? 'block' : 'none';
    }

    function formatISODuration(iso) {
      const m = iso ? iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/) : null;
      if (!m) return '0:00';
      const h = parseInt(m[1]||0,10);
      const mm = parseInt(m[2]||0,10);
      const s = parseInt(m[3]||0,10);
      const parts = [];
      if (h) parts.push(String(h).padStart(2,'0'));
      parts.push(String(mm).padStart(2,'0'));
      parts.push(String(s).padStart(2,'0'));
      return parts.join(':');
    }

    function savePlaylists() { localStorage.setItem('miniPlaylists', JSON.stringify(playlists)); }
    function saveRecently() { localStorage.setItem('recentlyPlayed', JSON.stringify(recentlyPlayed)); }
    function saveMigrationLog() { localStorage.setItem('migrationLog', JSON.stringify(migrationLog)); }

    // Guess artist/title from video title heuristics
    function guessArtistTitle(fullTitle, channel) {
      const parts = fullTitle.split(' - ');
      if (parts.length >= 2) {
        return { artist: parts[0].trim(), title: parts.slice(1).join(' - ').trim() };
      }
      return { artist: channel || '', title: fullTitle };
    }

    // iTunes artwork lookup (returns URL or null)
    async function fetchITunesArtwork(title, artist) {
      if (!title) return null;
      try {
        const q = encodeURIComponent(`${title} ${artist || ''}`);
        const url = `https://itunes.apple.com/search?term=${q}&entity=song&limit=1`;
        const r = await fetch(url);
        const j = await r.json();
        if (j.results && j.results.length) {
          const art = j.results[0].artworkUrl100 || j.results[0].artworkUrl60;
          if (art) return art.replace(/100x100bb/, '600x600bb');
        }
      } catch (e) { /* ignore */ }
      return null;
    }

    // Lyrics lookup (demo)
    async function fetchLyrics(artist, title) {
      try {
        const url = `https://api.lyrics.ovh/v1/${encodeURIComponent(artist)}/${encodeURIComponent(title)}`;
        const r = await fetch(url);
        if (!r.ok) return null;
        const j = await r.json();
        return j.lyrics || null;
      } catch (e) { return null; }
    }

    // ========== YouTube API helpers ==========
    async function ytSearch(query, maxResults = 12) {
      if (!YOUTUBE_API_KEY || YOUTUBE_API_KEY === 'REPLACE_WITH_YOUR_KEY') return [];
      const sUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&videoCategoryId=10&maxResults=${maxResults}&q=${encodeURIComponent(query)}&key=${YOUTUBE_API_KEY}`;
      const r = await fetch(sUrl);
      const j = await r.json();
      if (!j.items) return [];
      const ids = j.items.map(i => i.id.videoId).join(',');
      const detUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${ids}&key=${YOUTUBE_API_KEY}`;
      const dRes = await fetch(detUrl);
      const dJson = await dRes.json();
      const map = {};
      (dJson.items || []).forEach(it => { map[it.id] = it; });
      return j.items.map(item => {
        const id = item.id.videoId;
        const det = map[id];
        return {
          videoId:id,
          title:item.snippet.title,
          channel:item.snippet.channelTitle,
          thumbnail: (det && det.snippet && (det.snippet.thumbnails.maxres || det.snippet.thumbnails.high || det.snippet.thumbnails.medium)) ?
                     (det.snippet.thumbnails.maxres?.url || det.snippet.thumbnails.high?.url || det.snippet.thumbnails.medium?.url) :
                     (item.snippet.thumbnails.medium && item.snippet.thumbnails.medium.url),
          duration: det ? formatISODuration(det.contentDetails.duration) : null
        };
      });
    }

    // ========== RENDERING ==========
    function renderSidebarPlaylists() {
      playlistsList.innerHTML = '';
      const keys = Object.keys(playlists);
      if (!keys.length) {
        playlistsList.innerHTML = '<div class="muted">No playlists yet</div>';
        return;
      }
      keys.forEach(name => {
        const pl = playlists[name];
        const div = document.createElement('div');
        div.className = 'playlist-item';
        const img = document.createElement('img');
        img.className = 'playlist-cover';
        img.src = pl.cover || (pl.songs && pl.songs[0] && (pl.songs[0].artwork || pl.songs[0].thumbnail)) || 'https://via.placeholder.com/44';
        div.appendChild(img);
        const label = document.createElement('div');
        label.textContent = `${name} — ${pl.songs ? pl.songs.length : 0} songs`;
        div.appendChild(label);
        div.onclick = () => { showPlaylist(name); };
        playlistsList.appendChild(div);
      });
    }

    function renderHome() {
      // Greeting
      const hr = new Date().getHours();
      let greet = 'Good day';
      if (hr < 12) greet = 'Good morning';
      else if (hr < 18) greet = 'Good afternoon';
      else greet = 'Good evening';
      document.getElementById('greeting').textContent = `${greet}, ${userName}`;

      // Recently played grid (4x2 — last 8)
      recentGrid.innerHTML = '';
      const eight = recentlyPlayed.slice(-8).reverse();
      if (!eight.length) {
        recentGrid.innerHTML = '<div class="muted">No recently played songs.</div>';
      } else {
        eight.forEach(item => {
          const card = document.createElement('div');
          card.className = 'recent-item';
          const img = document.createElement('img');
          img.src = item.artwork || item.thumbnail || 'https://via.placeholder.com/88x56';
          const meta = document.createElement('div');
          meta.className = 'recent-meta';
          meta.innerHTML = `<div class="recent-title">${item.title}</div><div class="muted">${item.channel || item.artist || ''}</div>`;
          card.appendChild(img);
          card.appendChild(meta);
          card.onclick = () => playVideoById(item.videoId, item);
          recentGrid.appendChild(card);
        });
      }

      // Made playlists
      madePlaylistsDiv.innerHTML = '';
      const userPls = Object.keys(playlists);
      if (!userPls.length) {
        madePlaylistsDiv.innerHTML = '<div class="muted">No created playlists</div>';
      } else {
        userPls.forEach(name => {
          const row = document.createElement('div');
          row.className = 'playlist-item';
          row.style.justifyContent = 'space-between';
          const label = document.createElement('div');
          label.textContent = name;
          row.appendChild(label);
          const info = document.createElement('div');
          info.className = 'muted';
          info.textContent = `${playlists[name].songs ? playlists[name].songs.length : 0} songs`;
          row.appendChild(info);
          row.onclick = () => showPlaylist(name);
          madePlaylistsDiv.appendChild(row);
        });
      }

      // Auto-made playlists example: Top Recently
      autoPlaylistsDiv.innerHTML = '';
      const top = recentlyPlayed.slice(-12).reverse().slice(0, 12);
      if (!top.length) autoPlaylistsDiv.innerHTML = '<div class="muted">No auto playlists yet</div>';
      else {
        const row = document.createElement('div');
        row.className = 'playlist-item';
        row.style.justifyContent = 'space-between';
        row.innerHTML = `<div>Top Recently</div><div class="muted">${top.length} songs</div>`;
        row.onclick = () => showAutoPlaylist(top, 'Top Recently');
        autoPlaylistsDiv.appendChild(row);
      }
    }

    function renderSearchResults(items) {
      searchResultsDiv.innerHTML = '';
      if (!items.length) { searchResultsDiv.innerHTML = '<div class="muted">No results</div>'; return; }
      items.forEach(it => {
        const c = document.createElement('div');
        c.className = 'song-card';
        // For search results (non-video tab), prefer artwork if we can map to iTunes later; initially use thumbnail
        c.innerHTML = `
          <img class="song-art" src="${it.artwork || it.thumbnail || 'https://via.placeholder.com/88'}" alt="art">
          <div class="song-info">
            <div class="song-title">${it.title}</div>
            <div class="song-artist">${it.channel || it.artist || ''}</div>
            <div style="margin-top:8px">
              <button class="btn-play small">Play</button>
              <button class="btn-add small">Add to Playlist</button>
              <button class="btn-art small">iTunes Art</button>
            </div>
          </div>
        `;
        c.querySelector('.btn-play').onclick = () => playVideoById(it.videoId, it);
        c.querySelector('.btn-add').onclick = () => promptAddToPlaylist(it);
        c.querySelector('.btn-art').onclick = async () => {
          const guess = guessArtistTitle(it.title, it.channel);
          const art = await fetchITunesArtwork(guess.title, guess.artist);
          if (art) { c.querySelector('.song-art').src = art; alert('iTunes artwork applied to this result preview'); }
          else alert('No iTunes cover found');
        };
        searchResultsDiv.appendChild(c);
      });
    }

    function renderVideoResults(items) {
      videoResultsDiv.innerHTML = '';
      if (!items.length) { videoResultsDiv.innerHTML = '<div class="muted">No results</div>'; return; }
      items.forEach(it => {
        const c = document.createElement('div');
        c.className = 'video-card';
        c.innerHTML = `
          <img src="${it.thumbnail}" style="width:100%;height:120px;object-fit:cover;border-radius:6px;margin-bottom:8px">
          <div style="font-weight:700">${it.title}</div>
          <div class="muted" style="margin-top:6px">${it.channel} ${it.duration ? ' • ' + it.duration : ''}</div>
          <div style="margin-top:8px"><button class="btn-play small">Play Video</button></div>
        `;
        c.querySelector('.btn-play').onclick = () => playVideoById(it.videoId, it);
        videoResultsDiv.appendChild(c);
      });
    }

    function renderPlaylistsSidebarQuick() {
      // update quick covers (recent and auto top)
      const recentCover = recentlyPlayed.length ? (recentlyPlayed[recentlyPlayed.length-1].artwork || recentlyPlayed[recentlyPlayed.length-1].thumbnail) : 'https://via.placeholder.com/44';
      sidebarRecent.querySelector('img').src = recentCover;
      const autoCover = recentlyPlayed.length ? (recentlyPlayed[Math.max(0,recentlyPlayed.length-1)].artwork || recentlyPlayed[Math.max(0,recentlyPlayed.length-1)].thumbnail) : 'https://via.placeholder.com/44';
      sidebarAutoTop.querySelector('img').src = autoCover;
    }

    // ========== PLAYBACK ==========
    // IFrame API loading
    function loadYouTubeIframeAPI() {
      return new Promise((resolve) => {
        if (window.YT && window.YT.Player) return resolve();
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        window.onYouTubeIframeAPIReady = () => resolve();
      });
    }

    function ensurePlayer(videoId) {
      // keep iframe element id 'video-player' — player will be created once API ready
      if (!player) {
        if (window.YT && window.YT.Player) {
          player = new YT.Player('video-player', {
            height: '360', width: '100%', videoId: videoId,
            playerVars: { autoplay: 1, controls: 1, modestbranding: 1 },
            events: { onReady: (e)=>{ e.target.playVideo(); startTimeUpdater(); }, onStateChange: onPlayerStateChange }
          });
        } else {
          iframeEl.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&autoplay=1&controls=1&modestbranding=1`;
          const poll = setInterval(() => {
            if (window.YT && window.YT.Player) {
              clearInterval(poll);
              player = new YT.Player('video-player', {
                height: '360', width: '100%', videoId: videoId,
                playerVars: { autoplay: 1, controls: 1, modestbranding: 1 },
                events: { onReady: (e)=>{ e.target.playVideo(); startTimeUpdater(); }, onStateChange: onPlayerStateChange }
              });
            }
          }, 300);
        }
      } else {
        try { player.loadVideoById(videoId); }
        catch (e) { iframeEl.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&autoplay=1&controls=1&modestbranding=1`; }
      }
    }

    function playVideoById(videoId, meta = null) {
      currentVideo = meta || { videoId };
      // apply UI
      playerArea.style.display = 'block';
      nowTitle.textContent = currentVideo.title || 'Loading...';
      nowArtist.textContent = currentVideo.channel || currentVideo.artist || '';
      nowCover.src = currentVideo.artwork || currentVideo.thumbnail || 'https://via.placeholder.com/88';
      // update recently played
      const exists = recentlyPlayed.find(r => r.videoId === currentVideo.videoId);
      if (exists) recentlyPlayed = recentlyPlayed.filter(r => r.videoId !== currentVideo.videoId);
      recentlyPlayed.push({...currentVideo, playedAt: Date.now()});
      if (recentlyPlayed.length > 50) recentlyPlayed.shift();
      saveRecently();
      renderHome();
      renderPlaylistsSidebarQuick();
      // ensure player (even if iframe hidden on non-video tab, player still plays)
      ensurePlayer(videoId);
      // if not on video tab, hide iframe (so video is not shown)
      iframeEl.style.display = (activeTab === 'video') ? 'block' : 'none';
    }

    playBtn.onclick = () => { if (player && player.playVideo) player.playVideo(); };
    pauseBtn.onclick = () => { if (player && player.pauseVideo) player.pauseVideo(); };
    stopBtn.onclick = () => { if (player && player.stopVideo) player.stopVideo(); timeLabel.textContent = '00:00 / 00:00'; };
    closePlayerBtn.onclick = () => { playerArea.style.display = 'none'; };

    function onPlayerStateChange(e) { /* can respond to ended, etc. if needed */ }

    let timerInterval = null;
    function startTimeUpdater() {
      if (!player || !player.getCurrentTime) return;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        try {
          const cur = Math.floor(player.getCurrentTime());
          const dur = Math.floor(player.getDuration()) || 0;
          const fmt = s => {
            const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
            if (h) return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
            return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
          };
          timeLabel.textContent = `${fmt(cur)} / ${fmt(dur)}`;
        } catch (e) {}
      }, 700);
    }

    // spacebar toggles
    window.addEventListener('keydown', (ev) => {
      if (ev.code === 'Space' && (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA')) {
        ev.preventDefault();
        if (player && player.getPlayerState) {
          const st = player.getPlayerState();
          if (st === 1) player.pauseVideo();
          else player.playVideo();
        }
      }
    });

    // ========== SEARCH HANDLING ==========
    let searchDebounce = null;
    headerSearch.addEventListener('input', () => {
      clearTimeout(searchDebounce);
      searchDebounce = setTimeout(async () => {
        const q = headerSearch.value.trim();
        if (!q) return;
        lastSearchQuery = q;
        setActiveTab('search');
        searchQueryLabel.textContent = q;
        // perform search results for songs (show song cards: artwork, title, artist)
        const items = await ytSearch(q, 18);
        // For each item attempt to fetch iTunes artwork asynchronously and attach (not blocking render)
        const itemsWithArt = items.map(it => ({...it, artwork: null}));
        renderSearchResults(itemsWithArt);
        // fetch iTunes art in background
        itemsWithArt.forEach(async (it, idx) => {
          const guess = guessArtistTitle(it.title, it.channel);
          const art = await fetchITunesArtwork(guess.title, guess.artist);
          if (art) {
            it.artwork = art;
            // update DOM: naive approach — re-render whole results to show some art updated
            renderSearchResults(itemsWithArt);
          }
        });
        // also prepare video results for video tab separately
        renderVideoResults(items);
      }, 380);
    });

    // ========== PLAYLISTS UI ==========
    function promptAddToPlaylist(item) {
      const names = Object.keys(playlists);
      if (!names.length) {
        if (confirm('No playlists exist. Create one?')) {
          const name = prompt('Playlist name:');
          if (name) {
            playlists[name] = { songs: [item], cover: item.artwork || item.thumbnail || '' };
            savePlaylists();
            renderSidebarPlaylists();
            alert('Playlist created and song added.');
          }
        }
        return;
      }
      const pick = prompt(`Add to which playlist?\n${names.join('\n')}`);
      if (!pick) return;
      if (!playlists[pick]) playlists[pick] = { songs: [], cover: '' };
      playlists[pick].songs.push(item);
      playlists[pick].cover = playlists[pick].cover || (item.artwork || item.thumbnail || '');
      savePlaylists();
      renderSidebarPlaylists();
      alert(`Added to ${pick}`);
    }

    createPlaylistBtn.onclick = () => {
      const nm = prompt('New playlist name:');
      if (!nm) return;
      if (playlists[nm]) return alert('Playlist exists');
      playlists[nm] = { songs: [], cover: '' };
      savePlaylists();
      renderSidebarPlaylists();
    };

    function showPlaylist(name) {
      const pl = playlists[name];
      if (!pl) return alert('Playlist not found');
      setActiveTab('search'); // reuse search page UI to show playlist contents
      searchQueryLabel.textContent = `Playlist: ${name}`;
      const items = (pl.songs || []).map(s => s);
      renderSearchResults(items);
    }

    function showAutoPlaylist(items, title) {
      setActiveTab('search');
      searchQueryLabel.textContent = title;
      renderSearchResults(items);
    }

    sidebarRecent.onclick = () => {
      setActiveTab('search');
      searchQueryLabel.textContent = 'Recently Played';
      const rs = recentlyPlayed.slice().reverse().map(i => i);
      renderSearchResults(rs);
    };
    sidebarAutoTop.onclick = () => {
      const top = recentlyPlayed.slice(-12).reverse();
      showAutoPlaylist(top, 'Top Recently');
    };

    // ========== MIGRATION ==========
    // Migration scans legacy playlist keys and recentlyPlayed and creates migrationLog entries
    async function buildMigrationCandidates() {
      const keys = ['miniPlaylists', 'playlists', 'myPlaylists'];
      const candidates = [];
      for (const key of keys) {
        const raw = localStorage.getItem(key);
        if (!raw) con tinue;
        try {
          const obj = JSON.parse(raw);
          for (const name in obj) {
            const pl = obj[name];
            if (!pl || !Array.isArray(pl.songs)) continue;
            for (const song of pl.songs) {
              const isItunes = (song.preview || song.previewUrl || song.preview_url || song.artworkUrl100 || song.trackViewUrl) && !song.videoId;
              if (isItunes) {
                candidates.push({ key, playlist: name, original: song });
              }
            }
          }
        } catch (e) { /* ignore invalid */ }
      }
      // recentlyPlayed
      const rawRecent = localStorage.getItem('recentlyPlayed');
      if (rawRecent) {
        try {
          const arr = JSON.parse(rawRecent);
          for (const s of arr) {
            const isItunes = (s.preview || s.previewUrl || s.preview_url) && !s.videoId;
            if (isItunes) candidates.push({ key: 'recentlyPlayed', playlist: null, original: s });
          }
        } catch (e) {}
      }
      return candidates;
    }

    async function runMigrationAndLog() {
      if (!YOUTUBE_API_KEY || YOUTUBE_API_KEY === 'REPLACE_WITH_YOUR_KEY') {
        alert('Migration requires a valid YouTube API key set in the source.');
        return;
      }
      const candidates = await buildMigrationCandidates();
      if (!candidates.length) { alert('No iTunes-format songs found to migrate.'); return; }

      migrationLog = []; // reset log for this run
      saveMigrationLog();
      migrationModal.style.display = 'flex';

      let idx = 0;
      for (const c of candidates) {
        idx++;
        const orig = c.original;
        const title = orig.trackName || orig.title || orig.name || orig.track || '';
        const artist = orig.artistName || (orig.artist && (orig.artist.name || orig.artist)) || orig.artist || '';
        const query = `${title} ${artist}`.trim();
        let match = null;
        try {
          const results = await ytSearch(query, 4);
          match = results[0] || null;
        } catch (e) { match = null; }
        migrationLog.push({ id: migrationLog.length + 1, sourceKey: c.key, playlistName: c.playlist, original: { title, artist, raw: orig }, match, status: match ? 'pending' : 'failed' });
        saveMigrationLog();
        renderMigrationList();
        // small pause to be polite
        await new Promise(r => setTimeout(r, 220));
      }
      alert('Migration scan complete — review matches in the migration log. Click "Accept All" to apply.');
    }

    function renderMigrationList() {
      migrationList.innerHTML = '';
      if (!migrationLog.length) migrationList.innerHTML = '<div class="muted">No migration entries</div>';
      migrationLog.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'mapping-row';
        const orig = document.createElement('div');
        orig.className = 'mapping-original';
        orig.innerHTML = `<div style="font-weight:700">${entry.original.title || '(no title)'}</div><div class="muted">${entry.original.artist || ''}</div><div class="small muted">From: ${entry.sourceKey}${entry.playlistName ? ' / ' + entry.playlistName : ''}</div>`;
        const match = document.createElement('div');
        match.className = 'mapping-match';
        if (entry.match) {
          match.innerHTML = `<div style="font-weight:700">${entry.match.title}</div><div class="muted">${entry.match.channel || ''} ${entry.match.duration ? ' • ' + entry.match.duration : ''}</div>`;
        } else {
          match.innerHTML = `<div class="muted">No match found</div>`;
        }
        const actions = document.createElement('div');
        actions.className = 'mapping-actions';
        const status = document.createElement('div');
        status.textContent = entry.status;
        status.className = 'small muted';
        const acceptBtn = document.createElement('button');
        acceptBtn.textContent = 'Accept';
        acceptBtn.onclick = () => acceptMigrationEntry(entry.id);
        const retryBtn = document.createElement('button');
        retryBtn.textContent = 'Retry';
        retryBtn.onclick = () => retryMigrationEntry(entry.id);
        actions.appendChild(acceptBtn);
        actions.appendChild(retryBtn);
        actions.appendChild(status);

        row.appendChild(orig);
        row.appendChild(match);
        row.appendChild(actions);
        migrationList.appendChild(row);
      });
    }

    function acceptMigrationEntry(id) {
      const idx = migrationLog.findIndex(e => e.id === id);
      if (idx === -1) return;
      const entry = migrationLog[idx];
      if (!entry.match) { alert('No match to accept'); return; }
      // Apply match into stored playlists/recentlyPlayed
      try {
        if (entry.sourceKey === 'recentlyPlayed') {
          let recent = JSON.parse(localStorage.getItem('recentlyPlayed') || '[]');
          recent = recent.map(it => {
            // try match by title+artist raw
            const t = it.trackName || it.title || it.name || it.track || '';
            const a = it.artistName || (it.artist && (it.artist.name || it.artist)) || it.artist || '';
            if ((t === entry.original.title && a === entry.original.artist) || (it.preview && entry.original.raw && it.original && it.original.raw)) {
              return { videoId: entry.match.videoId, title: entry.match.title, channel: entry.match.channel, thumbnail: entry.match.thumbnail, duration: entry.match.duration };
            }
            return it;
          });
          localStorage.setItem('recentlyPlayed', JSON.stringify(recent));
          recentlyPlayed = recent;
        } else {
          const raw = localStorage.getItem(entry.sourceKey);
          if (raw) {
            const obj = JSON.parse(raw);
            if (obj && obj[entry.playlistName] && Array.isArray(obj[entry.playlistName].songs)) {
              obj[entry.playlistName].songs = obj[entry.playlistName].songs.map(s => {
                const t = s.trackName || s.title || s.name || s.track || '';
                const a = s.artistName || (s.artist && (s.artist.name || s.artist)) || s.artist || '';
                if (t === entry.original.title && a === entry.original.artist) {
                  return { videoId: entry.match.videoId, title: entry.match.title, channel: entry.match.channel, thumbnail: entry.match.thumbnail, duration: entry.match.duration };
                }
                return s;
              });
              // write back
              localStorage.setItem(entry.sourceKey, JSON.stringify(obj));
              if (entry.sourceKey === 'miniPlaylists') {
                playlists = JSON.parse(localStorage.getItem('miniPlaylists') || '{}');
                renderSidebarPlaylists();
              }
            }
          }
        }
        migrationLog[idx].status = 'accepted';
        saveMigrationLog();
        renderMigrationList();
        alert('Migration entry accepted and applied.');
      } catch (e) { console.error(e); alert('Failed to apply migration entry. See console.'); }
    }

    async function retryMigrationEntry(id) {
      const idx = migrationLog.findIndex(e => e.id === id);
      if (idx === -1) return;
      const entry = migrationLog[idx];
      const title = entry.original.title;
      const artist = entry.original.artist;
      const query = `${title} ${artist}`.trim();
      try {
        const results = await ytSearch(query, 4);
        entry.match = results[0] || null;
        entry.status = entry.match ? 'pending' : 'failed';
        saveMigrationLog();
        renderMigrationList();
        alert('Retry complete — review updated match.');
      } catch (e) { alert('Retry failed — check console'); console.error(e); }
    }

    acceptAllBtn.onclick = () => {
      if (!confirm('Accept all pending mappings? This will modify localStorage playlists & recentlyPlayed.')) return;
      migrationLog.forEach(entry => { if (entry.match && entry.status !== 'accepted') acceptMigrationEntry(entry.id); });
    };

    retryMigrationBtn.onclick = () => {
      // retry all failed
      const failed = migrationLog.filter(e => e.status === 'failed');
      if (!failed.length) return alert('No failed entries to retry.');
      (async () => {
        for (const e of failed) await retryMigrationEntry(e.id);
        alert('Retries completed.');
      })();
    };

    migrationOpen.onclick = () => {
      migrationModal.style.display = 'flex';
      renderMigrationList();
    };
    closeMigration.onclick = () => migrationModal.style.display = 'none';

    // ========== MIGRATION AUTO-RUN (scan only) ==========
    async function scanLegacyAndPopulateLog() {
      const candidates = await buildMigrationCandidates();
      migrationLog = [];
      let id=1;
      for (const c of candidates) {
        const orig = c.original;
        const title = orig.trackName || orig.title || orig.name || orig.track || '';
        const artist = orig.artistName || (orig.artist && (orig.artist.name || orig.artist)) || orig.artist || '';
        // do not run search here — mark as pending scanned mapping
        migrationLog.push({ id: id++, sourceKey: c.key, playlistName: c.playlist, original: { title, artist, raw: orig }, match: null, status: 'scanned' });
      }
      saveMigrationLog();
      // keep modal closed until user requests
    }

    // ========== INIT ==========
    async function init() {
      // UI wiring
      homeNav.onclick = () => setActiveTab('home');
      searchNav.onclick = () => setActiveTab('search');
      videoNav.onclick = () => setActiveTab('video');

      document.getElementById('migration-open').onclick = () => { migrationModal.style.display = 'flex'; renderMigrationList(); };

      // load local data
      playlists = JSON.parse(localStorage.getItem('miniPlaylists') || '{}');
      recentlyPlayed = JSON.parse(localStorage.getItem('recentlyPlayed') || '[]');
      migrationLog = JSON.parse(localStorage.getItem('migrationLog') || '[]');

      document.getElementById('greeting').textContent = `Hello, ${userName}`;

      // render
      renderSidebarPlaylists();
      renderHome();
      renderPlaylistsSidebarQuick();

      // load YT iframe API in background
      try { await loadYouTubeIframeAPI(); } catch (e) { console.warn('YT load failed', e); }

      // scan for legacy items (do not auto-migrate; create migration log entries)
      await scanLegacyAndPopulateLog();

      // wire migration run button inside modal if user wants a full automated migration:
      // We'll add a double-click behavior: if user opens modal and clicks Accept All after matches populated by runMigrationAndLog(), they can accept.
      document.getElementById('migration-open').addEventListener('dblclick', async () => {
        // double-click to run an automated scan+match (heavy)
        if (!confirm('Run migration now (performs YouTube searches to find matches)?')) return;
        await runMigrationAndLog();
      });

      // search on Enter as well
      headerSearch.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const q = headerSearch.value.trim();
          if (!q) return;
          lastSearchQuery = q;
          setActiveTab('search');
          searchQueryLabel.textContent = q;
          (async () => {
            const items = await ytSearch(q, 20);
            // try to fill artwork asynchronously
            const itemsWithArt = items.map(it => ({...it, artwork: null}));
            renderSearchResults(itemsWithArt);
            itemsWithArt.forEach(async (it) => {
              const guess = guessArtistTitle(it.title, it.channel);
              const art = await fetchITunesArtwork(guess.title, guess.artist);
              if (art) { it.artwork = art; renderSearchResults(itemsWithArt); }
            });
            renderVideoResults(items);
          })();
        }
      });

      // lyrics
      lyricsBtn.onclick = async () => {
        if (!currentVideo) return;
        const guess = guessArtistTitle(currentVideo.title, currentVideo.channel);
        const l = await fetchLyrics(guess.artist, guess.title);
        lyricsBox.style.display = l ? 'block' : 'none';
        lyricsBox.textContent = l || 'Lyrics not found.';
      };

      applyArtBtn.onclick = async () => {
        if (!currentVideo) return;
        const guess = guessArtistTitle(currentVideo.title, currentVideo.channel);
        const art = await fetchITunesArtwork(guess.title, guess.artist);
        if (art) {
          nowCover.src = art;
          // update recently played entry
          const idx = recentlyPlayed.findIndex(r => r.videoId === currentVideo.videoId);
          if (idx !== -1) { recentlyPlayed[idx].artwork = art; saveRecently(); renderHome(); }
          alert('iTunes artwork applied.');
        } else alert('No iTunes artwork found.');
      };

      // migration modal setup
      renderMigrationList();

      // initial focus
      headerSearch.placeholder = 'What do you want to play?';
    }

    init();
  </script>
</body>
</html>
